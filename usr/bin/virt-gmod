#!/bin/bash

# Arquivo de configuração do script
CONFIG_FILE="$HOME/.config/virt-qmod/virt-qmod.env"

# Verifica se o script está sendo executado como sudo
if [[ -n "$SUDO_USER" ]]; then
	# Se estiver rodando com sudo, redefinimos HOME para o diretório do usuário original
	# `eval echo ~$SUDO_USER` retorna o home do usuário que chamou o sudo
	HOME=$(eval echo ~"$SUDO_USER")

	# Atualizamos o caminho do arquivo de configuração para garantir que ele seja lido do usuário correto
	CONFIG_FILE="$HOME/.config/virt-qmod/virt-qmod.env"
fi

# Carrega o arquivo de configuração criado
# shellcheck source=/dev/null
source "$CONFIG_FILE"

# Binário virt-qmod
# VIRT_QMOD="virt-qmod" # Versão do sistema
VIRT_QMOD="/usr/bin/virt-qmod" # Versão local de teste
export VIRT_QMOD
echo "VIRT_QMOD: $VIRT_QMOD"

# Variáveis de mensagens do sistema
option1="Criar uma nova VM"
option2="Listar VMs"
option3="Iniciar uma VM"
option4="Parar uma VM"
option5="Remover uma VM"
option6="Abrir VM no Virt Viewer"
option7="Editar XML da VM"
option8="Listar snapshots de uma VM"
option9="Criar um snapshot"
option10="Deletar um snapshot"
option11="Restaurar um snapshot"
option12="Exibir informações do disco"
option13="Aumentar o tamanho do Disco da VM"
option14="Diminuir o tamanho do Disco da VM"
option15="Anexar ISO à VM"
option16="Desanexar ISO da VM"
option17="Sair"
column1="Opções"
title1="Gerenciar VMs"
button1="$option17"
text1="Opção inválida!"
# Função para executar comandos com sudo e mensagens do yad
run_with_sudo() {
	# Se não houver argumentos, sai silenciosamente
	[[ $# -eq 0 ]] && return 1

	local password
	# Captura a senha via YAD
	if ! password=$(yad --title="Autenticação Requerida" \
		--window-icon="dialog-password" \
		--text="O comando requer privilégios de administrador:" \
		--entry --hide-text --button="OK:0" --button="Cancelar:1"); then
		# Se o YAD retornar erro ou cancelar (exit code != 0)
		return 1
	fi

	[[ -z "$password" ]] && return 1

	# Executa usando o pipe para o sudo -S
	# O -- garante que o sudo não tente interpretar os argumentos do seu comando
	if echo "$password" | sudo -S -- "$@"; then
		echo "Comando executado com sucesso."
	else
		yad --error --text="Falha na autenticação ou erro no comando."
		return 1
	fi
}

# Função para selecionar uma VM existente
select_vm() {
	# Recebe o filtro (ativos, inativos ou todas). Se vazio, assume 'todas'.
	local FILTRO="${1:-todas}"
	local text

	# Obtém a lista baseada no parâmetro passado para o $VIRT_QMOD
	# Nota: Assumindo que seu $VIRT_QMOD aceita os argumentos que criamos na list_vms
	text=$($VIRT_QMOD list "$FILTRO" | sed '1,2d')

	# Verifica se a lista está vazia (evita abrir janela vazia)
	if [ -z "$text" ]; then
		yad --warning --text="Nenhuma VM encontrada no estado: $FILTRO" --timer=3
		return 1
	fi

	# Calcula dimensões da janela
	local lines
	lines=$(echo "$text" | wc -l)
	local max_length
	max_length=$(echo "$text" | awk '{ print length }' | sort -nr | head -1)

	local height=$((lines * 30 + 150))
	local width=$((max_length * 8 + 100)) # Aumentei um pouco o multiplicador para segurança

	# Exibe a lista usando o YAD
	# O awk '{print $2}' assume que o nome da VM é a segunda coluna na saída do $VIRT_QMOD
	# Exibe a lista usando o YAD
	local vm_name

	# SC2181 corrigido: Validamos o sucesso do comando YAD diretamente no IF
	if vm_name=$(echo "$text" | awk '{print $1}' | yad --list \
		--title="Selecione a VM ($FILTRO)" \
		--column="Nome da Máquina Virtual" \
		--button="Cancelar:1" \
		--button="Selecionar:0" \
		--height="$height" \
		--width="$width" \
		--center \
		--separator=""); then

		# Se entrou aqui, o usuário clicou em "Selecionar" (Status 0)
		# Verificamos se algo foi de fato selecionado
		[ -z "$vm_name" ] && return 1
		echo "$vm_name"
	else
		# Se entrou aqui, o usuário clicou em "Cancelar", fechou no X ou deu erro
		return 1
	fi

	# [ -z "$vm_name" ] && return 1

	# echo "$vm_name"
}

# Função para criar uma nova máquina virtual
create() {
	# Solicitar a seleção do arquivo ISO separadamente usando zenity antes do formulário
	local CDROM
	if ! CDROM=$(zenity --file-selection --title="Selecione a ISO de instalação"); then
		return
	fi

	local FORM_OUTPUT
	if ! FORM_OUTPUT=$(yad --form --title="Criar Máquina Virtual" --text="Preencha os detalhes da VM:" \
		--field="Nome da VM": "$NAME" \
		--field="RAM (em MB)": "$RAM" \
		--field="vCPUs": "$VCPUS" \
		--field="Tamanho do Disco (em GB)": "$DISK" \
		--field="Rede (padrão: ${NETWORK})": "$NETWORK" \
		--field="Gráficos":CB "spice,listen=0.0.0.0!vnc,listen=0.0.0.0" \
		--field="OS Variant":CB "${OSVARIANT:-}!$($VIRT_QMOD list_variant | tr '\n' '!')" \
		--separator="|" \
		--image="path/to/image/icon.png" \
		--image-on-top \
		--width=400 \
		--height=300); then
		return
	fi

	IFS='|' read -r VM_NAME RAM VCPUS DISK_SIZE NETWORK GRAPHICS OSVARIANT <<<"$FORM_OUTPUT"

	$VIRT_QMOD create --name "$VM_NAME" --ram "$RAM" --vcpus "$VCPUS" --disk "${DISK_SIZE}" --cdrom "$CDROM" --network "$NETWORK" --graphics "$GRAPHICS" --os-variant "$OSVARIANT"
	yad --info --text="VM criada com sucesso!" # --theme="Adwaita-dark"
}
# Função para listar VMs
list() {
	local text
	# Filtra os argumentos passados para a função (ativos, inativos ou todas)
	# se o seu $VIRT_QMOD list já suportar esses filtros.
	text=$($VIRT_QMOD list | sed '1,4d')

	# Se não houver VMs, avisa e sai
	if [ -z "$text" ]; then
		yad --info --text="Nenhuma VM encontrada." --timer=3 --center
		return 0
	fi

	# Cálculos de dimensões (ajustados para melhor visibilidade)
	local lines
	lines=$(echo "$text" | wc -l)
	local max_length
	max_length=$(echo "$text" | awk '{ print length }' | sort -nr | head -1)

	local height=$((lines * 35 + 100))
	local width=$((max_length * 10 + 50))

	# O segredo aqui: o awk formata a saída e o xargs passa para o yad
	echo "$text" | awk '{print $1; print $2; print $3}' | xargs yad --list \
		--title="Lista de VMs" \
		--width="$width" --height="$height" --center \
		--column="Id" --column="Nome" --column="Estado" \
		--button="OK:0"
}
# Função para iniciar uma VM
start() {
	# 1. Pega o retorno bruto
	local VM_NAME_RAW
	VM_NAME_RAW=$(select_vm inativos)

	# 2. Limpeza absoluta: pega só a 1ª linha e remove caracteres invisíveis
	local VM_NAME
	VM_NAME=$(echo "$VM_NAME_RAW" | head -n 1 | tr -d '\r\n[:space:]')

	# Debug para confirmar se limpou
	echo "VM_NAME_LIMPO: |$VM_NAME|"

	# 3. Executa se não estiver vazio
	if [ -n "$VM_NAME" ]; then
		$VIRT_QMOD start "$VM_NAME" &&
			yad --info --title="Sucesso" --text="VM <b>$VM_NAME</b> iniciada!" --button="OK:0" --center
	fi
}

# Função para parar uma VM
stop() {
	# 1. Pega o retorno bruto da seleção
	local VM_NAME_RAW
	VM_NAME_RAW=$(select_vm ativos)
	[ -z "$VM_NAME_RAW" ] && return 1

	# 2. Limpeza: pega a primeira linha e remove qualquer espaço ou quebra de linha
	# Isso resolve o problema das aspas extras e do nome duplicado
	local VM_NAME
	VM_NAME=$(echo "$VM_NAME_RAW" | head -n 1 | tr -d '[:space:]')

	# Debug opcional (pode comentar depois)
	echo "DEBUG: Parando a VM |$VM_NAME|"

	# 3. Executa o comando de parada forçada
	if [ -n "$VM_NAME" ]; then
		if $VIRT_QMOD stop_force "$VM_NAME"; then
			yad --info --title="Sucesso" \
				--text="A VM <b>$VM_NAME</b> foi parada (Force Stop)!" \
				--button="OK:0" --center
		fi
	fi
}

# Função para remover uma VM
remove() {
	VM_NAME=$(select_vm inativos)
	[ -n "$VM_NAME" ] && $VIRT_QMOD remove "$VM_NAME" && yad --info --text="VM '$VM_NAME' removida!"
}
# Função para abrir uma VM no virt-viewer
open() {
	VM_NAME=$(select_vm ativos)
	[ -n "$VM_NAME" ] && $VIRT_QMOD open "$VM_NAME" & disown
}
# Função para editar xml da VM
edit() {
	VM_NAME=$(select_vm inativos)
	[ -n "$VM_NAME" ] && $VIRT_QMOD edit "$VM_NAME"
}
# Função para listar snapshots
list_snapshots() {
	# 1. Seleciona e limpa o nome da VM (Garante apenas uma linha sem espaços extras)
	local VM_NOME_BRUTO
	VM_NOME_BRUTO=$(select_vm nomes)
	[ -z "$VM_NOME_BRUTO" ] && return 1

	local VM_NAME
	VM_NAME=$(echo "$VM_NOME_BRUTO" | head -n 1 | tr -d '[:space:]')

	# 2. Obtém os dados e remove o cabeçalho
	local text
	text=$($VIRT_QMOD list_snapshots "$VM_NAME" | sed '1,4d')

	# 3. Se não houver snapshots, avisa e sai
	if [ -z "$text" ] || [ "$(echo "$text" | tr -d '[:space:]')" = "" ]; then
		yad --info --title="Aviso" --text="Nenhum snapshot encontrado para <b>$VM_NAME</b>." \
			--button="OK:0" --center --width=300
		return 0
	fi

	# 4. Cálculos de dimensões
	local lines
	lines=$(echo "$text" | wc -l)
	local max_length
	max_length=$(echo "$text" | awk '{ print length }' | sort -nr | head -1)

	local height=$((lines * 35 + 100))
	local width=$((max_length * 10 + 100))

	# 5. O SEGREDO: awk '{print $1; print $2; print $3}' | xargs
	# Isso separa cada coluna para o YAD entender a grade
	echo "$text" | awk '{print $1; print $2; print $3}' | xargs yad --list \
		--title="Snapshots de $VM_NAME" \
		--width="$width" --height="$height" --center \
		--column="Nome" --column="Tempo de criação" --column="Estado" \
		--button="OK:0"
}
# Função para criar um snapshot
create_snapshot() {
	# 1. Seleciona a VM e garante que pegamos apenas UMA linha limpa
	local VM_NOME_BRUTO
	VM_NOME_BRUTO=$(select_vm nomes)
	[ -z "$VM_NOME_BRUTO" ] && return 1

	# Limpeza: pega a primeira linha, remove espaços e quebras de linha
	local VM_NAME
	VM_NAME=$(echo "$VM_NOME_BRUTO" | head -n 1 | tr -d '[:space:]')

	# 2. Conta quantos snapshots existem (contando linhas que começam com espaço/nome)
	# local TOTAL_SNAPS
	# TOTAL_SNAPS=$(virsh --connect "$SESSION" snapshot-list "$VM_NAME" | sed '1,2d' 2>/dev/null | grep -c "^ [a-zA-Z0-9]")

	# Se o grep falhar ou não achar nada, garante que é 0
	# [ -z "$TOTAL_SNAPS" ] && TOTAL_SNAPS=0

	# local PROXIMO_NUMERO=$((TOTAL_SNAPS + 1))

	# Se não informou o nome, gera o automático com timestamp
	local timestamp
	timestamp=$(date +"%Y%m%d-%H%M%S")
	local nome_snapshot
	nome_snapshot="${VM_NAME}-snap-${timestamp}"

	# 3. Define a sugestão limpa
	# local SUGESTAO="${VM_NAME}-snap-${PROXIMO_NUMERO}"
	local SUGESTAO="$nome_snapshot"

	# 4. Abre o yad
	local SNAPSHOT_NAME
	SNAPSHOT_NAME=$(yad --entry \
		--title="Criar Snapshot" \
		--text="Digite o nome do snapshot para a VM selecionada:" \
		--entry-text="$SUGESTAO" \
		--width=500 --center)

	[ -z "$SNAPSHOT_NAME" ] && return 1

	# 5. Executa a criação
	if $VIRT_QMOD create_snapshot "$VM_NAME" "$SNAPSHOT_NAME"; then
		yad --info --text="Snapshot <b>$SNAPSHOT_NAME</b> criado!" \
			--width=300 --center \
			--button="OK:0"
	fi
}
# Função para deletar um snapshot
delete_snapshot() {
	# 1. Seleciona e limpa o nome da VM (Garante apenas uma linha)
	local VM_NOME_BRUTO

	VM_NOME_BRUTO=$(select_vm nomes)

	[ -z "$VM_NOME_BRUTO" ] && return 1

	local VM_NAME
	VM_NAME=$(echo "$VM_NOME_BRUTO" | head -n 1 | tr -d '[:space:]')

	# Coleta dados básicos
	detalhes=$(virsh --connect "$SESSION" domblklist "$VM_NAME" --details | awk '/disk/')
	caminho_arquivo=$(echo "$detalhes" | awk '{print $4}' | head -n1)

	# 2. Busca a lista de snapshots existentes para ajudar o usuário
	# Usamos sed '1,4d' para pular o cabeçalho conforme seu teste anterior
	local SNAP_LIST
	SNAP_LIST=$($VIRT_QMOD list_snapshots "$VM_NAME" | sed '1,4d' | awk '{print $1}')

	if [ -z "$SNAP_LIST" ]; then
		yad --warning --title="Aviso" --text="Nenhum snapshot encontrado para <b>$VM_NAME</b>." --center --button="OK:0"
		return 1
	fi

	# 3. Em vez de digitar, o usuário seleciona da lista (Muito mais seguro!)
	local SNAPSHOT_NAME
	SNAPSHOT_NAME=$(echo "$SNAP_LIST" | yad --list \
		--title="Deletar Snapshot" \
		--text="Selecione o snapshot de <b>$VM_NAME</b> que deseja remover:" \
		--column="Nome do Snapshot" \
		--width=400 --height=300 --center \
		--button="Cancelar:1" --button="Deletar:0" \
		--separator="")

	[ -z "$SNAPSHOT_NAME" ] && return 1

	# 4. Confirmação antes de deletar
	yad --question --title="Confirmar" \
		--text="Tem certeza que deseja deletar <b>$SNAPSHOT_NAME</b>?\nEsta operação não pode ser desfeita." \
		--button="Não:1" --button="Sim:0" --center || return 1

	# 5. Chama o comando e exibe o resultado sem botão cancelar
	# Chama o run_with_sudo apenas com 'true' para validar a senha e abrir o cache
	if run_with_sudo true; then
		# Agora o sudo já está autenticado no terminal/sessão
		if $VIRT_QMOD delete_snapshot "$VM_NAME" "$SNAPSHOT_NAME"; then
			# O sudo -n (non-interactive) garante que ele use o cache.
			# Se o cache expirar, ele falha em vez de travar o script.
			sudo -n rm -f "$caminho_arquivo"

			yad --info --title="Sucesso" \
				--text="Snapshot <b>$SNAPSHOT_NAME</b> deletado!" \
				--button="OK:0" --center
		fi
	fi
}
restore_snapshots() {
    local VM_NOME_BRUTO
    # 1. Abre a interface de seleção (ou pega a seleção atual)
    VM_NOME_BRUTO=$(select_vm nomes)

    # 2. Se o usuário cancelou ou não selecionou nada
    [[ -z "$VM_NOME_BRUTO" ]] && return 1

    # 3. Limpeza cirúrgica do nome da VM
    local VM_NAME
    VM_NAME=$(echo "$VM_NOME_BRUTO" | head -n 1 | tr -d '[:space:]' | tr -d '|')

	# 2. Busca a lista de snapshots existentes para ajudar o usuário
	# Usamos sed '1,4d' para pular o cabeçalho conforme seu teste anterior
	local SNAP_LIST
	SNAP_LIST=$($VIRT_QMOD list_snapshots "$VM_NAME" | sed '1,4d' | awk '{print $1}')

	if [ -z "$SNAP_LIST" ]; then
		yad --warning --title="Aviso" --text="Nenhum snapshot encontrado para <b>$VM_NAME</b>." --center --button="OK:0"
		return 1
	fi

	# 3. Em vez de digitar, o usuário seleciona da lista (Muito mais seguro!)
	local SNAPSHOT_NAME
	SNAPSHOT_NAME=$(echo "$SNAP_LIST" | yad --list \
		--title="Deletar Snapshot" \
		--text="Selecione o snapshot de <b>$VM_NAME</b> que deseja restaurar:" \
		--column="Nome do Snapshot" \
		--width=400 --height=300 --center \
		--button="Cancelar:1" --button="Restaurar:0" \
		--separator="")

	[ -z "$SNAPSHOT_NAME" ] && return 1
    
    local SNAP_NAME
    SNAP_NAME=$(echo "$SNAP_LIST" | head -n 1 | tr -d '[:space:]' | tr -d '|')

    # 5. Confirmação Visual
    if yad --question --title="Confirmar Restauração" \
        --window-icon="document-revert" \
        --text="Deseja retornar a VM <b>$VM_NAME</b> para o estado: <b>$SNAP_NAME</b>?\n\n<i>Atenção: O estado atual será perdido!</i>" \
        --button="Cancelar:1" --button="Restaurar:0" --center; then

        # 6. Chama o backend
        if $VIRT_QMOD restore_snapshot "$VM_NAME" "$SNAP_NAME"; then
            yad --info --title="Sucesso" --text="VM restaurada!" --button="OK:0" --center
        else
            yad --error --title="Erro" --text="Falha na restauração." --center
        fi
    fi
}
# Função para exibir informações do disco
show_disk_info() {
	local VM_NOME_BRUTO
	VM_NOME_BRUTO=$(select_vm nomes)
	[ -z "$VM_NOME_BRUTO" ] && return 1

	# Limpeza rigorosa do nome da VM (remove a "seta" da imagem 1)
	local VM_NAME
	VM_NAME=$(echo "$VM_NOME_BRUTO" | head -n 1 | tr -d '[:space:]')

	# Captura a saída pulando o cabeçalho (ajuste o sed se sobrar título)
	local RawData
	RawData=$($VIRT_QMOD show_disk_info "$VM_NAME" | sed '1,4d')

	# Se estiver vazio, avisa
	if [ -z "$RawData" ]; then
		yad --info --text="Nenhuma informação de disco para $VM_NAME" --button="OK:0"
		return 1
	fi

	# Processa os dados para que Número+Unidade sejam um único argumento
	local FormattedData=()
	while read -r target cap_val cap_unit aloc_val aloc_unit phys_val phys_unit; do
		# Pula linhas vazias ou inválidas
		[ -z "$target" ] && continue

		FormattedData+=("$target")
		FormattedData+=("$cap_val $cap_unit")
		FormattedData+=("$aloc_val $aloc_unit")
		FormattedData+=("$phys_val $phys_unit")
	done <<<"$RawData"

	# Pega a quantidade de linhas de dados reais
	local lines
	lines=$(echo "$text" | wc -l)

	# Altura: 35 pixels por linha + 100 para o cabeçalho/botões
	# Limitamos a altura mínima e máxima para não ficar estranho
	local height=$((lines * 35 + 100))
	[ "$height" -gt 400 ] && height=400 # Teto máximo
	[ "$height" -lt 200 ] && height=200 # Chão mínimo

	# Largura: Reduzimos o multiplicador de 10 para 8
	local width=550 # Valor fixo costuma funcionar melhor para 4 colunas padrão

	# Abre o YAD usando o array formatado
	yad --list --title="Discos da VM: $VM_NAME" \
		--width="$width" --height="$height" --center \
		--column="Alvo" --column="Capacidade" \
		--column="Alocação" --column="Físico" \
		--button="OK:0" \
		"${FormattedData[@]}"
}

# Função para aumentar o tamanho do disco
resize_disk() {
	# 1. Seleção e limpeza do nome da VM
	local VM_NOME_BRUTO
	VM_NOME_BRUTO=$(select_vm nomes)
	[ -z "$VM_NOME_BRUTO" ] && return 1
	local VM_NAME
	VM_NAME=$(echo "$VM_NOME_BRUTO" | head -n 1 | tr -d '[:space:]')

	# 2. Pergunta o tamanho adicional (em GB)
	local DISK_SIZE
	DISK_SIZE=$(yad --entry \
		--title="Aumentar Disco: $VM_NAME" \
		--text="Informe o tamanho ADICIONAL em GB (ex: 5):" \
		--entry-text="5" \
		--button="Cancelar:1" --button="Confirmar:0" \
		--width=350 --center)
	[ -z "$DISK_SIZE" ] && return 1

	# 3. Executa a operação e captura o relatório
	# Usamos o run_with_sudo se o seu $VIRT_QMOD exigir privilégios
	# Executa e filtra: remove tudo que não seja as linhas do relatório
	local RELATORIO
	RELATORIO=$($VIRT_QMOD resize_disk "$VM_NAME" "$DISK_SIZE" | sed -n '/VM:/,$p')

	if [ -n "$RELATORIO" ]; then
		yad --info --title="Relatório de Disco" --width=400 --center \
			--text="<b>Processamento Concluído:</b>\n\n$RELATORIO" \
			--button="OK:0"
	else
		yad --error --title="Erro" \
			--text="Falha ao redimensionar o disco de <b>$VM_NAME</b>." \
			--center --button="OK:0"
	fi
}

# Função para diminuir o tamano do disco
shrink_disk() {
	# 1. Seleção da VM
	local VM_NOME_BRUTO
	VM_NOME_BRUTO=$(select_vm nomes)
	[[ -z "$VM_NOME_BRUTO" ]] && return 1

	local VM_NAME
	VM_NAME=$(echo "$VM_NOME_BRUTO" | head -n 1 | tr -d '[:space:]')

	# 2. ALERTA DE PERIGO (SC2181 evitado aqui)
	if ! yad --warning --title="PERIGO: Redução de Disco" --center --width=450 \
		--text="<b>ATENÇÃO!</b>\n\nDiminuir o disco virtual sem reduzir a partição interna\n<b>DESTRUIRÁ OS DADOS</b> da sua VM.\n\nAlém disso, qualquer <b>Snapshot Externo</b> será fundido e removido.\n\nDeseja mesmo prosseguir?" \
		--button="Abortar:1" --button="Prosseguir:0"; then
		return 1
	fi

	# 3. Pergunta o valor da redução
	local REDUCE_SIZE
	REDUCE_SIZE=$(yad --entry \
		--title="Reduzir Disco: $VM_NAME" \
		--text="Quanto deseja REMOVER em GB? (ex: 5):" \
		--entry-text="5" \
		--button="Cancelar:1" --button="Confirmar:0" \
		--width=350 --center)
	[[ -z "$REDUCE_SIZE" ]] && return 1

	# 4. Execução com Log em tempo real no YAD
	# O pipe captura tudo do $VIRT_QMOD (unificação + limpeza + resize)
	$VIRT_QMOD shrink_disk "$VM_NAME" "$REDUCE_SIZE" 2>&1 |
		yad --text-info --title="Operação de Disco: $VM_NAME" \
			--width=600 --height=400 --center --fontname="Monospace 10" \
			--button="Fechar:0"
}

# Função para atachar uma ISO na VM e configurar o BOOT CDROM como primeiro boot
detach_iso() {
    local VM_NOME_BRUTO
    VM_NOME_BRUTO=$(select_vm nomes)
    [[ -z "$VM_NOME_BRUTO" ]] && return 1

    local VM_NAME
    VM_NAME=$(echo "$VM_NOME_BRUTO" | head -n 1 | tr -d '[:space:]' | tr -d '|')

    # 1. Busca as mídias usando sua nova lógica
    local MEDIA_LIST
    MEDIA_LIST=$($VIRT_QMOD list_removable_media "$VM_NAME" | sed '1,2d')

    if [[ -z "$MEDIA_LIST" ]]; then
        yad --info --title="Aviso" --text="Nenhuma ISO montada encontrada em <b>$VM_NAME</b>." --center --button="OK:0"
        return 1
    fi

    # 2. Mostra a lista para o usuário escolher qual ejetar
    local SELECAO
    SELECAO=$(echo "$MEDIA_LIST" | yad --list --title="Ejetar ISO - $VM_NAME" \
        --column="Alvo" --column="Caminho da ISO" \
        --width=600 --height=300 --center \
        --button="Cancelar:1" --button="Ejetar:0")

    # shellcheck disable=SC2181
    [[ $? -ne 0 ]] && return 1

    # 3. Extrai o caminho da ISO da seleção (segunda coluna)
    local ISO_PATH
    ISO_PATH=$(echo "$SELECAO" | cut -d'|' -f2)

    # 4. Chama o detach no backend
    if $VIRT_QMOD detach_iso "$VM_NAME" "$ISO_PATH"; then
        yad --info --title="Sucesso" --text="ISO ejetada com sucesso!" --center --button="OK:0"
    else
        yad --error --title="Erro" --text="Falha ao ejetar a mídia." --center --button="OK:0"
    fi
}
attach_iso() {
	# 1. Seleção da VM
	local VM_NAME
	VM_NAME=$(select_vm nomes)
	[[ -z "$VM_NAME" ]] && return 1

	# 2. Seleção do Arquivo ISO via explorador de arquivos (YAD)
	local ISO_FILE
	if ! ISO_FILE=$(yad --file --title="Selecionar ISO para $VM_NAME" \
		--file-filter="Arquivos ISO | *.iso" \
		--window-icon="drive-optical" \
		--width=800 --height=600 --center); then
		return 1 # Usuário cancelou a seleção
	fi

	# Valida se o arquivo selecionado existe (prevenção extra)
	[[ ! -f "$ISO_FILE" ]] && {
		yad --error --text="Arquivo não encontrado!"
		return 1
	}

	# 3. Execução (Chamando o virt-qmod e respeitando SC2181)
	# Nota: Assumindo que seu virt-qmod attach_iso aceita os parâmetros: VM_NAME e ISO_FILE
	if "$VIRT_QMOD" attach_iso "$VM_NAME" "$ISO_FILE"; then
		yad --info --title="Sucesso" \
			--text="A ISO <b>$(basename "$ISO_FILE")</b> foi anexada à VM <b>$VM_NAME</b>." \
			--button="OK:0" --center
	else
		yad --error --title="Erro" \
			--text="Falha ao anexar a ISO. Verifique se a VM possui um dispositivo de CD-ROM disponível." \
			--button="OK:0" --center
	fi
}

# Definição do array de opções
options=(
	"$option1"
	"$option2"
	"$option3"
	"$option4"
	"$option5"
	"$option6"
	"$option7"
	"$option8"
	"$option9"
	"$option10"
	"$option11"
	"$option12"
	"$option13"
	"$option14"
	"$option15"
	"$option16"
	# "$option17"
)

# Menu principal
while true; do
	num_options=${#options[@]}
	height=$((num_options * 32)) # Altura
	width=400                    # Largura fixa para evitar cortes

	OPTION=$(yad --list --title="$title1" --button="$button1:1" \
		--column="$column1" "${options[@]}" \
		--height=$height --width=$width | awk -F'|' '{print $1}')

	# Se o usuário clicar em "Voltar", sair do loop
	[ -z "$OPTION" ] && exit 0

	case "$OPTION" in
	"$option1") create ;;
	"$option2") list ;;
	"$option3") start ;;
	"$option4") stop ;;
	"$option5") remove ;;
	"$option6") open ;;
	"$option7") edit ;;
	"$option8") list_snapshots ;;
	"$option9") create_snapshot ;;
	"$option10") delete_snapshot ;;
	"$option11") restore_snapshots ;;
	"$option12") show_disk_info ;;
	"$option13") resize_disk ;;
	"$option14") shrink_disk ;;
	"$option15") attach_iso ;;
	"$option16") detach_iso ;;
	"$option17") exit 0 ;;
	*) yad --error --text="$text1" ;;
	esac
done
